#if defined _float_included
#endinput
#endif
#define _float_included
#pragma rational Float
enum floatround_method {
floatround_round = 0,
floatround_floor,
floatround_ceil,
floatround_tozero
};
enum anglemode {
radian = 0,
degrees,
grades
};
native Float:float(value);
native Float:floatstr(const string[]);
native Float:floatfract(Float:value);
native floatround(Float:value, floatround_method:method=floatround_round);
native floatcmp(Float:fOne, Float:fTwo);
native Float:floatsqroot(Float:value);
native Float:floatpower(Float:value, Float:exponent);
native Float:floatlog(Float:value, Float:base=10.0);
native Float:floatsin(Float:value, anglemode:mode=radian);
native Float:floatcos(Float:value, anglemode:mode=radian);
native Float:floattan(Float:value, anglemode:mode=radian);
native Float:floatsinh(Float:angle, anglemode:mode=radian);
native Float:floatcosh(Float:angle, anglemode:mode=radian);
native Float:floattanh(Float:angle, anglemode:mode=radian);
native Float:floatabs(Float:value);
native Float:floatatan(Float:angle, {anglemode,_}:radix);
native Float:floatacos(Float:angle, {anglemode,_}:radix);
native Float:floatasin(Float:angle, {anglemode,_}:radix);
native Float:floatatan2(Float:x, Float:y, {anglemode,_}:radix);
native Float:floatmul(Float:oper1, Float:oper2);
native Float:floatdiv(Float:dividend, Float:divisor);
native Float:floatadd(Float:dividend, Float:divisor);
native Float:floatsub(Float:oper1, Float:oper2);
native Float:operator*(Float:oper1, Float:oper2) = floatmul;
native Float:operator/(Float:oper1, Float:oper2) = floatdiv;
native Float:operator+(Float:oper1, Float:oper2) = floatadd;
native Float:operator-(Float:oper1, Float:oper2) = floatsub;
stock Float:operator++(Float:oper)
return oper+1.0;
stock Float:operator--(Float:oper)
return oper-1.0;
stock Float:operator-(Float:oper)
return oper^Float:cellmin;                                     
stock Float:operator*(Float:oper1, oper2)
return floatmul(oper1, float(oper2));                         
stock Float:operator/(Float:oper1, oper2)
return floatdiv(oper1, float(oper2));
stock Float:operator/(oper1, Float:oper2)
return floatdiv(float(oper1), oper2);
stock Float:operator+(Float:oper1, oper2)
return floatadd(oper1, float(oper2));                         
stock Float:operator-(Float:oper1, oper2)
return floatsub(oper1, float(oper2));
stock Float:operator-(oper1, Float:oper2)
return floatsub(float(oper1), oper2);
stock bool:operator==(Float:oper1, Float:oper2)
return floatcmp(oper1, oper2) == 0;
stock bool:operator==(Float:oper1, oper2)
return floatcmp(oper1, float(oper2)) == 0;                          
stock bool:operator!=(Float:oper1, Float:oper2)
return floatcmp(oper1, oper2) != 0;
stock bool:operator!=(Float:oper1, oper2)
return floatcmp(oper1, float(oper2)) != 0;                          
stock bool:operator>(Float:oper1, Float:oper2)
return floatcmp(oper1, oper2) > 0;
stock bool:operator>(Float:oper1, oper2)
return floatcmp(oper1, float(oper2)) > 0;
stock bool:operator>(oper1, Float:oper2)
return floatcmp(float(oper1), oper2) > 0;
stock bool:operator>=(Float:oper1, Float:oper2)
return floatcmp(oper1, oper2) >= 0;
stock bool:operator>=(Float:oper1, oper2)
return floatcmp(oper1, float(oper2)) >= 0;
stock bool:operator>=(oper1, Float:oper2)
return floatcmp(float(oper1), oper2) >= 0;
stock bool:operator<(Float:oper1, Float:oper2)
return floatcmp(oper1, oper2) < 0;
stock bool:operator<(Float:oper1, oper2)
return floatcmp(oper1, float(oper2)) < 0;
stock bool:operator<(oper1, Float:oper2)
return floatcmp(float(oper1), oper2) < 0;
stock bool:operator<=(Float:oper1, Float:oper2)
return floatcmp(oper1, oper2) <= 0;
stock bool:operator<=(Float:oper1, oper2)
return floatcmp(oper1, float(oper2)) <= 0;
stock bool:operator<=(oper1, Float:oper2)
return floatcmp(float(oper1), oper2) <= 0;
stock bool:operator!(Float:oper)
forward operator%(Float:oper1, Float:oper2);
forward operator%(Float:oper1, oper2);
forward operator%(oper1, Float:oper2);
stock Float:floatmin(Float:ValueA, Float:ValueB)
{
if (ValueA<=ValueB)
{
return ValueA;
}
return ValueB;
}
stock Float:floatmax(Float:ValueA, Float:ValueB)
{
if (ValueA>=ValueB)
{
return ValueA;
}
return ValueB;
}
stock Float:floatclamp(Float:Value, Float:MinValue, Float:MaxValue)
{
if (Value<=MinValue)
{
return MinValue;
}
if (Value>=MaxValue)
{
return MaxValue;
}
return Value;
